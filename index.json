[{"content":"Cet article fait partie d\u0026rsquo;une suite de tutoriels d\u0026rsquo;intégration Payzen dans une application web d\u0026rsquo;e-shopping. Vous trouverez le précédent article ici.\nIntroduction Après voir créé l\u0026rsquo;inventaire, nous allons maintenant implémenter le paiement, et plus particulièrement le paiement comptant immédiat.\nUser Story En tant qu\u0026rsquo;utilisateur Je veux payer le produit sélectionné Afin de créer une commande Déroulement Pour faire ce paiement, nous utilisons la librairie PayzenJS.\nLa documentation de cette librairie nous indique que nous devons signer notre requête de génération de formulaire via une requête POST vers un backend, ce qui coïncide avec la documentation Payzen de paiement comptant immédiat.\nNous allons donc tout d\u0026rsquo;abord créer un formulaire dans notre frontend, puis nous passerons les valeurs des champs dans la propriété orderData de la librarie.\nEnsuite nous implémenterons la génération de signature dans le backend, pour enfin renseigner l\u0026rsquo;url de l\u0026rsquo;endpoint dans la propriété credentials de la librairie.\nNous renseignerons également la propriété target comme étant égale à secure.osb.pf, afin d\u0026rsquo;utiliser la plateforme spécifique à OSB, car c\u0026rsquo;est celle-ci qui accepte les cartes privatives.\nEnfin, nous renseignerons la propriété canvas, qui contiendra l\u0026rsquo;iframe contenant le formulaire de paiement final.\nLa librarie s\u0026rsquo;occupera de faire la requête POST vers le backend, de récupérer la signature, d\u0026rsquo;envoyer la requêté signée à la plateforme, et enfin d\u0026rsquo;afficher le formulaire dans l\u0026rsquo;iframe.\nFrontend Item Dans un premier temps, modifions notre composant Item comme suit :\n// components/item.js export default function Item({item, buy}) { return ( \u0026lt;div className=\u0026#34;bg-white shadow overflow-hidden sm:rounded-lg hover:opacity-75\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col p-4 border-b border-gray-200\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row gap-1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Name:\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{item.name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row gap-1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Price:\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{item.price} \u0026lt;span\u0026gt;XPF\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col p-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; className=\u0026#34;custom-button custom-button-primary\u0026#34; onClick={() =\u0026gt; buy(item)}\u0026gt;Buy\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } Nous avons enlevé la classe cursor-pointer de la div principale, afin d\u0026rsquo;utiliser un bouton à la place (meilleur pour l\u0026rsquo;accessibilité web).\nEnsuite nous avons placé la fonction buy dans les props du composant afin que le parent ait le contrôle de la fonction à exécuter.\nEnfin, si vous voulez savoir comment est stylisé le bouton, le style se trouve dans le fichier global.css :\n/* styles/global.css */ @tailwind base; @tailwind components; @tailwind utilities; body { @apply bg-gray-200; } .custom-button { @apply w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 text-base text-center font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 sm:w-auto sm:text-sm; } .custom-button-primary { @apply bg-teal-600 text-white hover:bg-teal-700 focus:ring-teal-500; } Modal Maintenant nous devons implémenter la fonction buy dans le parent, qui est le fichier index.js. Mais nous allons être confrontés à un problème, en effet, cette fonction va utiliser la librairie PayzenJS, qui va afficher le formulaire de paiement dans une iframe.\nNous ne voulons pas afficher l\u0026rsquo;iframe telle quelle dans la page, ce n\u0026rsquo;est pas très esthétique.\nÀ la place, nous voulons afficher cette iframe dans un composant Modal, qui sera par défaut cachée, qui s\u0026rsquo;affichera au clic sur un bouton Buy, et qui pourra être fermée.\nAfin d\u0026rsquo;avoir un meilleur affichage de l\u0026rsquo;iframe dans la modale, nous allons utiliser la librarie @tailwindcss/aspect-ratio et plus particulièrement les classes aspect-w-1 et aspect-h-1.\n/* package.json */ \u0026#34;devDependencies\u0026#34;: { \u0026#34;@tailwindcss/aspect-ratio\u0026#34;: \u0026#34;^0.4.0\u0026#34;, [...] } npm install touch components/modal.js // components/modal.js export default function Modal({content, close}) { return ( \u0026lt;div className=\u0026#34;relative z-10\u0026#34; aria-labelledby=\u0026#34;modal-title\u0026#34; role=\u0026#34;dialog\u0026#34; aria-modal=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;fixed z-10 inset-0 overflow-y-auto\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex items-end sm:items-center justify-center min-h-full p-4 text-center sm:p-0\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;relative bg-white rounded-lg shadow-xl\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col gap-2\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row justify-end\u0026#34;\u0026gt; \u0026lt;button className=\u0026#34;text-xl text-gray-500 font-bold\u0026#34; onClick={() =\u0026gt; close()}\u0026gt;X\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex content-center justify-center aspect-w-1 aspect-h-1\u0026#34;\u0026gt; {content} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } La prop content est un slot, c\u0026rsquo;est dans cette prop qu\u0026rsquo;on mettra l\u0026rsquo;iframe.\nLa prop close est une fonction qui sera appelée lorsqu\u0026rsquo;on voudra fermer la modale sans poursuivre le paiement.\nIl nous reste maintenant à gérer l\u0026rsquo;affichage de cette modale, c\u0026rsquo;est dans le parent, index.js que nous allons le faire :\n// pages/index.js import Head from \u0026#39;next/head\u0026#39;; import Item from \u0026#39;../components/item\u0026#39;; import Modal from \u0026#39;../components/modal\u0026#39;; import * as React from \u0026#34;react\u0026#34;; export default function Home({ data }) { const [displayModal, setDisplayModal] = React.useState(false) const buy = (item) =\u0026gt; { setDisplayModal(true); // TODO paiement } const onCloseModal = () =\u0026gt; { setDisplayModal(false); } return ( \u0026lt;div className=\u0026#34;flex flex-col p-2\u0026#34;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Tutoriel Payzen e-shopping\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div className=\u0026#39;flex flex-row content-center justify-center\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;flex flex-col content-center justify-center gap-2\u0026#39;\u0026gt; \u0026lt;h1 className=\u0026#34;font-bold text-lg text-gray-600 text-center\u0026#34;\u0026gt;Boutique\u0026lt;/h1\u0026gt; \u0026lt;div className=\u0026#39;grid grid-cols-4 grid-flow-row gap-2\u0026#39;\u0026gt; {data.inventory.map((item, i) =\u0026gt; \u0026lt;Item key={i} item={item} buy={buy}/\u0026gt;)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={displayModal ? \u0026#39;block\u0026#39; : \u0026#39;hidden\u0026#39;}\u0026gt; \u0026lt;Modal content={\u0026lt;div id=\u0026#34;paymentCanvas\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;} close={onCloseModal}\u0026gt;\u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ) } Nous utilisons le hook useState afin de gérer l\u0026rsquo;état d\u0026rsquo;affichage de la modale.\nRetour de paiement Une fois que le paiement sera fait, comme le décrit la documentation Payzen du formulaire de paiement, nous serons redirigés vers l\u0026rsquo;url correspondante: vads_url_success en cas de paiement validé, vads_url_return en cas de paiement refusé.\nNous allons donc créer 2 pages, success.js et fail.js qui nous serviront de callback url, ces pages nous permettront aussi de retourner sur la page principale.\nmkdir pages/payment-result touch pages/payment-result/fail.js touch pages/payment-result/success.js // pages/payment-result/fail.js import { useRouter } from \u0026#39;next/router\u0026#39; export default function Fail() { const router = useRouter() return ( \u0026lt;div className=\u0026#34;flex flex-col gap-4\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Paiement échoué\u0026lt;/h1\u0026gt; \u0026lt;button className=\u0026#39;custom-button custom-button-primary\u0026#39; onClick={() =\u0026gt; router.push(\u0026#39;/\u0026#39;)}\u0026gt;Retour\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } // pages/payment-result/success.js import { useRouter } from \u0026#39;next/router\u0026#39; export default function Success() { const router = useRouter() return ( \u0026lt;div className=\u0026#34;flex flex-col gap-4\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Paiement réussi\u0026lt;/h1\u0026gt; \u0026lt;button className=\u0026#39;custom-button custom-button-primary\u0026#39; onClick={() =\u0026gt; router.push(\u0026#39;/\u0026#39;)}\u0026gt;Retour\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } PayzenJS Nos composants sont prêts, on passe à l\u0026rsquo;implémentation du paiement, procédons à l\u0026rsquo;installation de PayzenJS.\n/* package.json */ \u0026#34;dependencies\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;PayzenJS\u0026#34;: \u0026#34;1.0.5\u0026#34;, \u0026#34;react\u0026#34;: \u0026#34;17.0.2\u0026#34;, \u0026#34;react-dom\u0026#34;: \u0026#34;17.0.2\u0026#34; }, npm install La librarie PayzenJS a besoin que le DOM soit initialisé, le plus simple pour nous est de charger cette librarie via le hook useEffect qui permet d\u0026rsquo;avoir un comportement proche de la fonction componentDidMount d\u0026rsquo;un React.Component, qui se lance une fois le DOM chargé.\n// pages/index.js [...] import * as React from \u0026#34;react\u0026#34;; let PayzenJS; export async function getServerSideProps() { [...] } export default function Home({ data }) { const [displayModal, setDisplayModal] = React.useState(false) React.useEffect(() =\u0026gt; { PayzenJS = require(\u0026#39;PayzenJS/payzenjs\u0026#39;); }, []); [...] } Enfin, il nous reste à utiliser cette librarie :\n// pages/index.js const buy = (item) =\u0026gt; { setDisplayModal(true); PayzenJS.go({ // plateforme Payzen à utiliser, ne pas changer target: \u0026#34;secure.osb.pf\u0026#34;, // données du canvas où l\u0026#39;iframe sera intégré canvas: { id: \u0026#34;paymentCanvas\u0026#34;, // id de la div cible width: \u0026#34;1000px\u0026#34;, // largeur de l\u0026#39;iframe height: \u0026#34;1000px\u0026#34; // hauteur de l\u0026#39;iframe }, /* données du formulaire, * cf. doc : https://secure.osb.pf/doc/fr-FR/form-payment/standard-payment/creer-un-paiement-comptant-immediat.html * cf. doc : https://secure.osb.pf/doc/fr-FR/form-payment/standard-payment/gerer-les-moyens-de-paiement-proposes-a-l-acheteur.html */ orderData: { vads_action_mode: \u0026#34;INTERACTIVE\u0026#34;, vads_order_id: `TEST-${Math.round(Math.random() * 1000)}`, vads_site_id: \u0026#34;12345678\u0026#34;, vads_ctx_mode: \u0026#34;TEST\u0026#34;, // TEST | PRODUCTION vads_amount: item.price, vads_currency: \u0026#34;953\u0026#34;, // XPF vads_payment_cards: \u0026#34;\u0026#34;, // laisser vide pour afficher tous les types de cartes vads_language: \u0026#34;fr\u0026#34;, // laisser \u0026#39;fr\u0026#39; car par défaut c\u0026#39;est la langue \u0026#39;en\u0026#39; vads_theme_config: \u0026#39;MODE_IFRAME=false;FORM_TARGET=_top\u0026#39;, // affichage et comportement du theme, MODE_IFRAME=false =\u0026gt; affichage complet, FORM_TARGET=_top =\u0026gt; navigation vads_redirect_success_timeout: 5, // timeout du redirect après paiement accepté vads_redirect_error_timeout: 3, // timeout du redirect après paiement refusé vads_url_success: `http://localhost:3000/payment-result/success`, // url retour paiement accepté vads_url_return: `http://localhost:3000/payment-result/fail`, // url retour paiement refusé vads_return_mode: \u0026#34;POST\u0026#34; // valeur nécessaire pour que le mode d\u0026#39;affichage de la page de retour soit pris en compte }, credentials : { // endpoint retournant la signature du formulaire, cf. dossier backend source: `http://localhost:3001/sign` } }); } C\u0026rsquo;est tout pour notre frontend, passons maintenant au backend.\nBackend Pour notre backend, nous stockerons d\u0026rsquo;abord notre certificat dans un fichier .env afin de ne pas le mettre en dur dans le code (et de ne pas le mettre dans git), en utilisant la librarie dotenv.\nNous ferons des requêtes à partir d\u0026rsquo;un autre serveur (le frontend est sur le port 3000, et le backend sur le port 3001), et donc être confrontés à un problème de CORS, c\u0026rsquo;est pourquoi nous utiliserons le module cors.\nDe plus, la librarie PayzenJS nous enverra un formulaire sous forme d\u0026rsquo;objet JSON, pour pouvoir l\u0026rsquo;interpréter, nous utilisons body-parser.\nEnfin, nous devrons hasher et signer les données de notre formulaire, nous utiliserons la librarie crypto-js pour cela.\nCe qui nous donne les dépendances suivantes :\n/* package.json */ \u0026#34;dependencies\u0026#34;: { \u0026#34;express\u0026#34;: \u0026#34;4.17.2\u0026#34;, \u0026#34;cors\u0026#34;: \u0026#34;2.8.5\u0026#34;, \u0026#34;crypto-js\u0026#34;: \u0026#34;4.1.1\u0026#34;, \u0026#34;dotenv\u0026#34;: \u0026#34;16.0.0\u0026#34;, \u0026#34;body-parser\u0026#34;: \u0026#34;1.20.0\u0026#34; } Installez les modules :\nnpm install Dotenv Dans le dossier backend, placez le certificat dans un fichier .env :\ntouch .env # .env CERTIFICATE=\u0026lt;secret\u0026gt; Et récupérez-le dans le serveur :\n// main.js require(\u0026#39;dotenv\u0026#39;).config(); // modules serveur const express = require(\u0026#34;express\u0026#34;); [...] // clé de la boutique disponible dans le back office commerçant Payzen const certificate = process.env.CERTIFICATE; [...] CORS Utilisez cors dans votre serveur:\n// main.js // modules serveur const express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#39;cors\u0026#39;); [...] // middlewares app.use(cors()); app.options(\u0026#39;*\u0026#39;, cors()); [...] Body-parser Utlisez body-parser dans votre serveur :\n// main.js const cors = require(\u0026#39;cors\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); [...] // middlewares app.use(cors()); app.options(\u0026#39;*\u0026#39;, cors()); app.use(bodyParser.json()); [...] Signature Avant de commencer à utiliser crypto-js, nous devons savoir quelles fonctions de cette librarie nous allons utiliser.\nCette documentation nous indique que nous devons utiliser hmacSHA256 et Base64.\nNous devons trier les noms de champs commençant par \u0026ldquo;vads_\u0026rdquo; par ordre alphabétique, concaténer leur valeur associée dans une variable, séparées par des \u0026ldquo;+\u0026rdquo;, et rajouter le certificat à la fin de cette variable.\nCe qui nous donne finalement ce fichier main.js :\n// main.js // dotenv require(\u0026#39;dotenv\u0026#39;).config(); // modules serveur const express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#39;cors\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); // modules signature const hmacSHA256 = require(\u0026#39;crypto-js/hmac-sha256\u0026#39;); const Base64 = require(\u0026#39;crypto-js/enc-base64\u0026#39;); const app = express(); const port = 3001; // middlewares app.use(cors()); app.options(\u0026#39;*\u0026#39;, cors()); app.use(bodyParser.json()); // clé de la boutique disponible dans le back office commerçant Payzen const certificate = process.env.CERTIFICATE; app.post(\u0026#34;/sign\u0026#34;, (req, res) =\u0026gt; { var orderData = req.body; console.log(orderData); // transformer les données de orderData en chaine : \u0026#34;VALEUR_1+VALEUR_2+...+VALEUR_N+CERTIFICAT\u0026#34; let dataToSign = \u0026#34;\u0026#34;; Object.keys(orderData).sort().forEach((key) =\u0026gt; { if(key.slice(0,5) === \u0026#39;vads_\u0026#39;) { dataToSign += `${orderData[key]}+`; } }) dataToSign += `${certificate}`; // calcul de la signature, l\u0026#39;algorithme à utiliser est défini dans le back office commerçant Payzen let signature = Base64.stringify(hmacSHA256(dataToSign, certificate)); // retourner la signature res.send({signature: signature}); }); app.listen(port, () =\u0026gt; { console.log(`Payzen e-shopping backend server listening on port ${port}`); }); Test Nous sommes maintenant prêts à tester notre application.\nEn cliquant sur le bouton Buy du premier Item nous voyons le formulaire de paiement s\u0026rsquo;afficher dans la modale.\nAttention: les données de test sont uniquement possibles si vous avez bien spécifié la valeur TEST dans le paramètre vads_ctx_mode.\nEn cliquant sur une des cartes, par exemple \u0026ldquo;Banque Socredo Verte\u0026rdquo;, nous voyons une liste de cartes de test. En cliquant sur l\u0026rsquo;une d\u0026rsquo;entre elle, le formulaire va automatiquement remplir les champs.\nRemarque : À côté de chaque carte se trouve un scénario associé, si vous voulez tester un paiement accepté, vous devez choisir la 1ère carte.\nPuis, en cliquant sur valider, vous verrez le formulaire pour le code reçu par SMS, aussi appelé OTP pour One Time Password.\nEn mode TEST, vous pouvez juste recopier la valeur affichée, ou cliquer sur la valeur.\nEnfin, si vous avez bien choisi la carte associé au \u0026ldquo;paiement accepté\u0026rdquo;, vous obtiendrez l\u0026rsquo;écran de commande validée.\nVous pouvez ensuite soit attendre la redirection automatique, soit cliquer sur \u0026ldquo;retourner à la boutique\u0026rdquo;, pour aller sur la page /payment-result/success.\nNous voyons dans les DevTools que cette redirection est en fait une requête POST, avec les données suivantes.\nConclusion Dans cet article, nous avons utilisé la librarie PayzenJS afin d\u0026rsquo;afficher le formulaire de paiement dans une iframe contenue dans une modale.\nNous avons ainsi réussi à faire un paiement, et nous avons été redirigé vers la page de paiement réussi de notre application web.\nMais le travail ne s\u0026rsquo;arrête pas ici, en effet, une fois que le paiement est effectué, validé ou non, il nous reste à exploiter les données de retour afin de déclencher la suite de la commande, ou d\u0026rsquo;avertir le client que sa commande n\u0026rsquo;est pas passée.\nDe plus, nous devons valider qu\u0026rsquo;il s\u0026rsquo;agit bien de notre transaction, et non d\u0026rsquo;une requête forgée.\nNous verrons cela dans le prochain article.\n","permalink":"https://huangmanutea.github.io/blog.dev/posts/payzen_e-shopping_formulaire/paiement/","summary":"Cet article fait partie d\u0026rsquo;une suite de tutoriels d\u0026rsquo;intégration Payzen dans une application web d\u0026rsquo;e-shopping. Vous trouverez le précédent article ici.\nIntroduction Après voir créé l\u0026rsquo;inventaire, nous allons maintenant implémenter le paiement, et plus particulièrement le paiement comptant immédiat.\nUser Story En tant qu\u0026rsquo;utilisateur Je veux payer le produit sélectionné Afin de créer une commande Déroulement Pour faire ce paiement, nous utilisons la librairie PayzenJS.\nLa documentation de cette librairie nous indique que nous devons signer notre requête de génération de formulaire via une requête POST vers un backend, ce qui coïncide avec la documentation Payzen de paiement comptant immédiat.","title":"Payzen e-shopping formulaire - Paiement"},{"content":"Cet article fait partie d\u0026rsquo;une suite de tutoriels d\u0026rsquo;intégration Payzen dans une application web d\u0026rsquo;e-shopping. Vous trouverez le précédent article ici.\nIntroduction L\u0026rsquo;une des composantes principales d\u0026rsquo;une application de e-shopping est d\u0026rsquo;avoir une base de données de produits.\nChaque produit possède différentes propriétés, comme le prix à l\u0026rsquo;unité et le nom du produit.\nAfin de nous focaliser sur le paiement, nous n\u0026rsquo;allons pas créer de base de données, nous n\u0026rsquo;allons pas implémenter une API, ni faire d\u0026rsquo;appel d\u0026rsquo;API.\nNous allons uniquement instancier une liste d\u0026rsquo;objets produits en guise d\u0026rsquo;inventaire.\nUser Story En tant qu\u0026rsquo;utilisateur Je veux voir tous les produits que je peux acheter Afin de choisir le produit que je veux acheter Création de l\u0026rsquo;inventaire Dans pages/index.js, créer l\u0026rsquo;inventaire dans la fonction getServerSideProps comme suit:\n// pages/index.js export async function getServerSideProps() { // for tutorial purposes, easier to understand than a loop const data = { inventory: [ { id: 1, name: \u0026#34;article 1\u0026#34;, price: 1000 }, { id: 2, name: \u0026#34;article 2\u0026#34;, price: 2000 }, { id: 3, name: \u0026#34;article 3\u0026#34;, price: 3000 }, { id: 4, name: \u0026#34;article 4\u0026#34;, price: 4000 }, { id: 5, name: \u0026#34;article 5\u0026#34;, price: 5000 }, { id: 6, name: \u0026#34;article 6\u0026#34;, price: 6000 } ] } // Pass data to the page via props return { props: { data } } } ... Ce qui nous permettra ensuite de récupérer l\u0026rsquo;inventaire dans la page de cette façon\n// pages/index.js ... export default function Home({ data }) { console.log(data.inventory) return ( \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Tutoriel Payzen e-shopping\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;main\u0026gt; \u0026lt;h1 className=\u0026#34;title\u0026#34;\u0026gt; Welcome to \u0026lt;a href=\u0026#34;https://nextjs.org\u0026#34;\u0026gt;Next.js!\u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;style jsx global\u0026gt;{` `}\u0026lt;/style\u0026gt; \u0026lt;/div\u0026gt; ) } Sur le site (dans votre navigateur), si vous ouvrez les DevTools (F12 pour Windows), vous verez l\u0026rsquo;inventaire.\nAffichage Nous allons maintenant afficher l\u0026rsquo;inventaire sur la page.\nTout d\u0026rsquo;abord nous devons créer un composant Item\nmkdir components touch components/item.js // components/item.js export default function Item({item}) { const buy = () =\u0026gt; { console.log(item) } return ( \u0026lt;div className=\u0026#34;bg-white shadow overflow-hidden sm:rounded-lg hover:opacity-75 cursor-pointer\u0026#34; onClick={buy}\u0026gt; \u0026lt;div className=\u0026#34;flex flex-col px-4 py-5 sm:px-6\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row gap-1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Name:\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{item.name}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;flex flex-row gap-1\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Price:\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{item.price} \u0026lt;span\u0026gt;XPF\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } Il devrait ressembler à ça:\nNous implémenterons la fonction buy dans un autre article.\nNous devons ensuite transformer l\u0026rsquo;inventaire en composants Item, pour pouvoir l\u0026rsquo;afficher dans la page index.js.\n// pages/index.js import Head from \u0026#39;next/head\u0026#39; import Item from \u0026#39;../components/item\u0026#39; export async function getServerSideProps() { // for tutorial purposes, easier to understand than a loop const data = { inventory: [ { id: 1, name: \u0026#34;article 1\u0026#34;, price: 1000 }, { id: 2, name: \u0026#34;article 2\u0026#34;, price: 2000 }, { id: 3, name: \u0026#34;article 3\u0026#34;, price: 3000 }, { id: 4, name: \u0026#34;article 4\u0026#34;, price: 4000 }, { id: 5, name: \u0026#34;article 5\u0026#34;, price: 5000 }, { id: 6, name: \u0026#34;article 6\u0026#34;, price: 6000 } ] } // Envoi des données à la page via props return { props: { data } } } export default function Home({ data }) { return ( \u0026lt;div className=\u0026#34;flex flex-col p-2\u0026#34;\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Tutoriel Payzen e-shopping\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div className=\u0026#39;flex flex-row content-center justify-center\u0026#39;\u0026gt; \u0026lt;div className=\u0026#39;flex flex-col content-center justify-center gap-2\u0026#39;\u0026gt; \u0026lt;h1 className=\u0026#34;font-bold text-lg text-gray-600 text-center\u0026#34;\u0026gt;Boutique\u0026lt;/h1\u0026gt; \u0026lt;div className=\u0026#39;grid grid-cols-4 grid-flow-row gap-2\u0026#39;\u0026gt; {data.inventory.map((item, i) =\u0026gt; \u0026lt;Item key={i} item={item}/\u0026gt;)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; ) } Vous devriez maintenant avoir cet affichage\nEn cliquant sur l\u0026rsquo;un des Item, vous verrez apparaître dans la console, l\u0026rsquo;objet item associé.\nConclusion Nous venons d\u0026rsquo;implémenter une liste de produits et de l\u0026rsquo;afficher. Nous venons également de préparer la sélection de l\u0026rsquo;article à acheter.\nDans le prochain article, nous verrons comment transformer cette sélection d\u0026rsquo;article en paiement.\n","permalink":"https://huangmanutea.github.io/blog.dev/posts/payzen_e-shopping_formulaire/inventaire/","summary":"Cet article fait partie d\u0026rsquo;une suite de tutoriels d\u0026rsquo;intégration Payzen dans une application web d\u0026rsquo;e-shopping. Vous trouverez le précédent article ici.\nIntroduction L\u0026rsquo;une des composantes principales d\u0026rsquo;une application de e-shopping est d\u0026rsquo;avoir une base de données de produits.\nChaque produit possède différentes propriétés, comme le prix à l\u0026rsquo;unité et le nom du produit.\nAfin de nous focaliser sur le paiement, nous n\u0026rsquo;allons pas créer de base de données, nous n\u0026rsquo;allons pas implémenter une API, ni faire d\u0026rsquo;appel d\u0026rsquo;API.","title":"Payzen e-shopping formulaire - Inventaire"},{"content":"Introduction Dans cette série d\u0026rsquo;articles nous verrons ensemble comment implémenter Payzen By OSB dans une application web fullstack d\u0026rsquo;e-shopping basique.\nUne liste de produits, accompagnés de leur prix, sera affichée,. L\u0026rsquo;utilisateur pourra acheter un produit.\nAfin d\u0026rsquo;avoir une meilleure idée de l\u0026rsquo;architecture finale de l\u0026rsquo;application, nous allons tout d\u0026rsquo;abord expliquer Payzen By OSB, que j\u0026rsquo;appellerai Payzen pour aller plus vite.\nNote:\nJe ne vais pas créer de bases de données pour les produits et l\u0026rsquo;inventaire, ni pour la gestion des clients. Nous allons nous concentrer sur le paiement. Par la suite vous pourrez de vous-même brancher ce paiement à vos services de commande et de gestion client.\nPrésentation de Payzen Payzen est une plateforme permettant de payer avec différentes cartes, de plusieurs manières différentes:\nAPI formulaire de redirection (avec ou sans iFrame) API REST dépôt de fichier Note: A l\u0026rsquo;heure actuelle, il n\u0026rsquo;est pas possible de payer avec une carte privative avec l\u0026rsquo;API REST, une livraison est en cours pour débloquer cette situation.\nLa méthode la plus répandue est d\u0026rsquo;utiliser l\u0026rsquo;API formulaire de redirection. Elle va nous permettre de générer un formulaire qui pourra par la suite être intégré directement dans l\u0026rsquo;application via une iFrame, ou d\u0026rsquo;envoyer au client, par SMS ou par email, un lien vers ce formulaire.\nDans cette série d\u0026rsquo;articles, nous allons implémenter le formulaire de redirection via iFrame, c\u0026rsquo;est d\u0026rsquo;ailleurs ce que font les modules d\u0026rsquo;intégrations Payzen dans les CMS.\nPour préparer notre implémentation, nous devons récupérer notre identifiant boutique ainsi que notre clé d\u0026rsquo;API formulaire, vous pouvez vous référer à cette documentation, je vous conseille de télécharger la documentation au format PDF pour faciliter les recherches.\nPour ma part, je vais utiliser ces informations de test:\nidentifiant boutique: 97409611 (boutique de test de l\u0026rsquo;OSB)\nclé d\u0026rsquo;API: \u0026lt;secret\u0026gt;\nArchitecture La documentation de Payzen nous informe que nous avons besoin de la clé d\u0026rsquo;API, associée au bon identifiant boutique, afin de calculer la signature. En effet, c\u0026rsquo;est la signature qui permet de vérifier que c\u0026rsquo;est bien votre application qui envoie une commande.\nNous allons forcément faire un frontend, mais nous ne voulons surtout pas stocker la clé d\u0026rsquo;API dans le frontend. Pour cela nous aurons besoin d\u0026rsquo;un backend que nous appellerons pour calculer la signature à chaque création de formulaire.\nNotre architecture finale devrait ressembler à ceci:\nEt le diagramme de séquence:\nLa cinématique étant la suivante:\nl\u0026rsquo;utilisateur clique sur un bouton pour payer, le front envoie les données de paiement au back pour récupérer le calcul de la signature du formulaire, une fois la signature reçue, le front envoie les données de paiement + la signature à secure.osb.pf qui est la plateforme de paiement de Payzen, la plateforme de paiement vérifie la signature, et retourne le formulaire, l\u0026rsquo;utilisateur pourra ensuite renseigner ses informations de carte dans le formulaire et valider, enfin, la plateforme de paiement retournera un résultat OK ou KO, qui redirigera l\u0026rsquo;utilisateur sur la page /success ou /fail du front. Concernant la stack technologique, nous allons utiliser:\nNode.js pour le backend, Next.js pour le frontend, avec la librairie PayzenJS qui permettra d\u0026rsquo;intégrer facilement l\u0026rsquo;iFrame dans notre frontend. Notes:\nAvec Next.js il est tout à fait possible de placer le calcul de la signature dans pages/api, mais je préfère créer un backend dédié car certains parmi vous ont peut-être un microservice dédié au paiement.\nStructure des articles Les articles ne seront pas séparés en frontend et backend. D\u0026rsquo;un point de vue gestion de projet, il me paraît plus logique de développer le back et le front en même temps pour une feature.\nJe structurerai chaque fonctionnalité par une ou plusieurs User Stories, pour ceux qui connaissent la méthode Scrum.\nInitialisation du projet # créer le dossier mkdir tutorial-payzen-e-shopping cd tutorial-payzen-e-shopping Initialisation du backend Initialiser le projet backend avec npm\nmkdir backend cd backend npm init \u0026gt;package name: (backend) tutorial-payzen-e-shopping-back \u0026gt;version: (1.0.0) \u0026gt;description: backend du tutoriel payzen e-shopping \u0026gt;entry point: (index.js) main.js \u0026gt;test command: \u0026gt;git repository: \u0026gt;keywords: \u0026gt;author: HUANG Manutea \u0026gt;license: (ISC) MIT Rajouter la dépendance express dans le package.json, ainsi que le script start\n\u0026#34;scripts\u0026#34;: { ..., \u0026#34;start\u0026#34;: \u0026#34;node main.js\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;express\u0026#34;: \u0026#34;4.17.2\u0026#34;, }, Lancer l\u0026rsquo;installation\nnpm install Créer le fichier main.js\n// main.js // modules serveur const express = require(\u0026#34;express\u0026#34;); const app = express(); const port = 3001; app.post(\u0026#34;/sign\u0026#34;, (req, res) =\u0026gt; { res.send(\u0026#34;hello world!\u0026#34;); }); app.listen(port, () =\u0026gt; { console.log(`Payzen e-shopping backend server listening on port ${port}`); }); lancer le serveur\nnpm start Dans un autre terminal, lancer curl\ncurl -X POST http://localhost:3001/sign \u0026gt;hello world! Update (30/05/2022): un ami m\u0026rsquo;a dit que curl -X POST n\u0026rsquo;existe pas en Powershell, vous pouvez également utiliser Postman ou Insomnia si vous voulez.\nInitialisation du frontend Créer le projet frontend avec npx:\n# retourner à la racine du projet cd .. # créer le projet npx create-next-app frontend --use-npm --example \u0026#34;https://github.com/vercel/next-learn/tree/master/basics/learn-starter\u0026#34; Pour styliser l\u0026rsquo;affichage, nous allons utiliser TailwindCSS\ncd frontend npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p Ajouter nos composants au path de tailwind\n// tailwind.config.js module.exports = { content: [ \u0026#34;./pages/**/*.{js,ts,jsx,tsx}\u0026#34;, \u0026#34;./components/**/*.{js,ts,jsx,tsx}\u0026#34;, ], theme: { extend: {}, }, plugins: [], } Créer un fichier styles/global.css\n/* styles/global.css */ @tailwind base; @tailwind components; @tailwind utilities; Créer un fichier pages/_app.js\n// pages/_app.js import \u0026#39;../styles/global.css\u0026#39;; export default function MyApp({ Component, pageProps }) { return \u0026lt;Component {...pageProps} /\u0026gt; } Lancer le front en mode développement\nnpm run dev En utilisant un navigateur, allez à http://localhost:3000.\nConclusion Nous avons parcouru la documentation de Payzen. Cette documentation nous a indiqué comment récupérer les informations importantes d\u0026rsquo;identifiant boutique et de clé d\u0026rsquo;API.\nElle nous a également informé que pour générer un formulaire, la plateforme de paiement a besoin d\u0026rsquo;une signature permettant de signer la requête de création de formulaire.\nDe ce fait, nous avons conçu une architecture backend/frontend et nous les avons initialisé.\nPar la suite, nous allons implémenter les fonctionnalités nécessaires à notre application web d\u0026rsquo;e-shopping.\nLa liste des articles tutoriels:\nPayzen e-shopping formulaire - Inventaire TODO ","permalink":"https://huangmanutea.github.io/blog.dev/posts/payzen_e-shopping_formulaire/introduction/","summary":"Introduction Dans cette série d\u0026rsquo;articles nous verrons ensemble comment implémenter Payzen By OSB dans une application web fullstack d\u0026rsquo;e-shopping basique.\nUne liste de produits, accompagnés de leur prix, sera affichée,. L\u0026rsquo;utilisateur pourra acheter un produit.\nAfin d\u0026rsquo;avoir une meilleure idée de l\u0026rsquo;architecture finale de l\u0026rsquo;application, nous allons tout d\u0026rsquo;abord expliquer Payzen By OSB, que j\u0026rsquo;appellerai Payzen pour aller plus vite.\nNote:\nJe ne vais pas créer de bases de données pour les produits et l\u0026rsquo;inventaire, ni pour la gestion des clients.","title":"Payzen e-shopping formulaire - Introduction"},{"content":"Introduction Je souhaite que la Polynésie Française se modernise, les moyens de paiement sont un des axes d\u0026rsquo;amélioration où je peux aider. Dans ce but, je pense créer une série d\u0026rsquo;articles et de tutoriels sur les moyens de paiement, et plus particulièrement sur Payzen By OSB, à commencer par cet article.\nUpdate (12/05/2022): suite à quelques feedback, je me rend compte que cet article est à destination des développeurs de site de e-shopping, des commerçants, de mes confrères monéticiens. Cet article sera complexe à lire si vous n\u0026rsquo;avez jamais travaillé avec un TPE, avec une plateforme de paiement, avec des cartes bancaires.\nDisclaimer: Au moment où j\u0026rsquo;écris cet article, je travaille à l\u0026rsquo;Océanienne des Services Bancaires (OSB), mes articles seront orientés vers les solutions d\u0026rsquo;OSB car ce sont celles avec lesquelles je suis le plus familier. Ces articles ne sont pas sponsorisés par OSB, et j\u0026rsquo;encourage les gens à faire des tutoriels pour les solutions des autres fournisseurs de solutions de paiement.\nLes différents types de carte En Polynésie Française, il est possible de payer avec plusieurs types de cartes.\nCarte Bancaire (anciennement Carte Bleue, co-brandées ou non de Visa ou Mastercard), American Express (AMEX), Cartes privatives (Socredo Verte / Gold, Banque de Polynésie Hoa, CCP de Fare Rata, Carte Tiare de la Banque de Tahiti), Union Pay International (UPI), Discover, Japan Credit Bureau (JCB) Les 3 derniers types de cartes sont surtout utilisés par les touristes.\nLes cartes privatives composent la majorité des cartes détenues par les habitants de la Polynésie Française.\nPourquoi autant de personnes ont une carte privative ? Les cartes privatives sont proposées par les différentes banques de la place (à l\u0026rsquo;exception d\u0026rsquo;OFINA qui émet exclusivement les cartes AMEX). Il s\u0026rsquo;agit des banques Socredo, Banque de Tahiti, Banque de Polynésie, et Fare Rata.\nLes cartes privatives sont soumises à des réglementations et des frais moins coûteux que les cartes internationales.\nEn outre, elles sont uniquement régulées par les banques de la place, contrairement aux cartes bancaires internationales, qui sont non seulement régulées par les banques de la place, mais aussi par les réseaux internationaux (CB, Visa, Mastercard, Union Pay, etc.).\nC\u0026rsquo;est en partie à cause de ces réglementations et frais moins coûteux que les clients des banques doivent remplir moins de conditions pour avoir une carte locale. C\u0026rsquo;est pour cela que les cartes privatives sont plus répandues sur le territoire.\nNotes:\nLes réseaux peuvent décider d\u0026rsquo;appliquer des amendes voire de désactiver le flux vers un acteur monétaire (banque, processeur de paiement, etc.) si celui-ci ne respecte pas la réglementation. Cette réglementation est mise à jour régulièrement.\nPour les cartes privatives, ce sont les banques de la place qui imposent leur réglementation, par abus de langage, on parle aussi de réseau privatif pour désigner l\u0026rsquo;ensemble de ces banques.\nCes réglementations sont suivies par les banques centrales des pays, par exemple l\u0026rsquo;IEOM en Polynésie Française.\nJ\u0026rsquo;ai inclus la carte Tiare de la Banque de Tahiti dans les cartes privatives car elle a les mêmes limitations géographiques que celles-ci[1], mais il s\u0026rsquo;agit bien d\u0026rsquo;une CB, donc elle est soumise aux réglementations CB.\nLes cartes Socredo privatives sont maintenant co-brandées UPI, mais il y a bien 2 applications dans la carte, sur le territoire, c\u0026rsquo;est l\u0026rsquo;application privative qui est utilisée, à l\u0026rsquo;international, c\u0026rsquo;est l\u0026rsquo;application UPI qui est utilisée.\n[1]: Update (16/05/2022): La carte Tiare est une CB nationale, elle fonctionne également en France, mais pas à l\u0026rsquo;étranger.\nFonctionnement des transactions Le schéma à 4 coins est l\u0026rsquo;un des schémas de référence de la monétique. Il explique les entités qui entrent en jeu dans une transaction.\nLa banque émettrice émet la carte et la fournit au porteur.\nLa banque acquéreuse fournit un contrat accepteur au commerçant, afin que celui-ci puisse encaisser les paiements avec les cartes, moyennant une commission, en plus des services annexes autour de l\u0026rsquo;encaissement (exemple: relevé TPE). Les TPE et solutions de paiement en ligne sont des services d\u0026rsquo;encaissement.\nUn système d\u0026rsquo;acceptation est un logiciel ou un ensemble de logiciels, qui permet d\u0026rsquo;encaisser une carte bancaire, par exemple les TPE et les plateformes de paiement en ligne.\nIl existe 2 modes de fonctionnement pour le déroulement d\u0026rsquo;un paiement:\nle mode single message le mode dual message Lorsque vous payez avec votre carte, vous réalisez une transaction. Si toutes les règles de gestion sont validées, la transaction est autorisée.\nEn single message, la transaction autorisée est directement transformée en mouvement financier, i.e. un enregistrement est créé chez la banque acquéreuse qui dit \u0026ldquo;M. Client doit 1000 XPF à M. Commerçant\u0026rdquo;.\nEn dual message, la transaction est enregistrée sur le TPE, ou sur la plateforme de paiement, puis, tous les jours à une certaine heure, l\u0026rsquo;ensemble des transactions de la journée sont envoyées à la banque acquéreuse sous forme de mouvement financier.\nEn Polynésie Française, le mode dual message est le plus répandu, c\u0026rsquo;est d\u0026rsquo;ailleurs pour ça que l\u0026rsquo;on vous demande de ne pas débrancher votre TPE, votre internet, votre réseau électrique.\nLes cartes et les systèmes d\u0026rsquo;acceptation Pour qu\u0026rsquo;un système d\u0026rsquo;acceptation puisse encaisser une carte, elle doit reconnaître la carte.\nPour reconnaître une carte, on utilise le BIN, qui sont les N premiers chiffres du numéro de la carte, N étant défini par le réseau.\nDe plus, seule une application spécifique à ce réseau peut reconnaître cette carte. Par exemple, pour une transaction avec une carte AMEX sur un TPE, c\u0026rsquo;est uniquement une application TPE AMEX qui pourra la reconnaître, mais seulement si la carte fait partie d\u0026rsquo;une plage de BIN acceptée par l\u0026rsquo;application.\nNote: Dans un TPE, il peut y avoir plusieurs applications, quand une carte est insérée, le TPE demande à chaque application \u0026ldquo;Peux-tu accepter cette carte?\u0026rdquo;.\nDe la même manière, pour une plateforme de paiement en ligne, celle-ci ne pourra accepter que des cartes qui font partie de ses plages de BIN déclarées.\nZoom sur le paiement en ligne en Polynésie Française Comme énoncé précédemment, les cartes privatives sont majoritaires en Polynésie Française, et elles ne sont pas reconnues à l\u0026rsquo;étranger (sauf pour les cartes Socredo co-brandées UPI, comme cité précédemment) car les BIN privatifs ne sont pas déclarés dans le monde.\nC\u0026rsquo;est pour cela qu\u0026rsquo;on ne peut pas payer avec une carte privative sur la plupart des plateformes de paiement en ligne (Paypal, Stripe, etc.).\nPour remédier à ce problème, OSB propose Payzen, qui est actuellement la solution la plus connue qui accepte les cartes privatives. La Banque de Tahiti quant à elle vient de lancer SystemPay, un produit concurrent.\nÀ mon avis, à l\u0026rsquo;heure actuelle, c\u0026rsquo;est vers ces solutions que je conseille les commerçants d\u0026rsquo;aller, car il serait dommage de se priver des cartes privatives, alors qu\u0026rsquo;elles sont plus nombreuses.\nNotes:\nLes 2 solutions sont en réalité basées sur les solutions Payzen et SystemPay de Lyra, société située en France. Certains d\u0026rsquo;entre vous ont d\u0026rsquo;ailleurs peut-être déjà été confus en recherchant de la documentation sur ces solutions et se sont perdus entre la documentation Payzen d\u0026rsquo;OSB, la documentation Payzen de Lyra, la documentation SystemPay de la Banque de Tahiti, et la documentation SystemPay de Lyra.\nJe vous conseille de vous focaliser sur les documentations locales, et ensuite de compléter avec les documentations de Lyra.\nConclusion En Polynésie Française, la plus grande part des cartes bancaires sont des cartes privatives, pour des raisons économiques et réglementaires.\nLe fonctionnement même des systèmes d\u0026rsquo;acceptation impose quels types de cartes ils peuvent accepter, de ce fait, un commerçant local qui cherche une solution de paiement en ligne devrait se tourner vers les plateformes qui acceptent les cartes privatives.\nC\u0026rsquo;est à partir de ce raisonnement que dans les articles suivants, je présenterai comment implémenter Payzen By OSB sur une application web fullstack.\nSi vous utilisez un CMS du style Odoo ou Prestashop, il existe des modules déjà tout faits pour intégrer Payzen dans votre site. Je ne parlerai pas des CMS dans cette série d\u0026rsquo;articles.\n","permalink":"https://huangmanutea.github.io/blog.dev/posts/intro-moyens-paiement/","summary":"Introduction Je souhaite que la Polynésie Française se modernise, les moyens de paiement sont un des axes d\u0026rsquo;amélioration où je peux aider. Dans ce but, je pense créer une série d\u0026rsquo;articles et de tutoriels sur les moyens de paiement, et plus particulièrement sur Payzen By OSB, à commencer par cet article.\nUpdate (12/05/2022): suite à quelques feedback, je me rend compte que cet article est à destination des développeurs de site de e-shopping, des commerçants, de mes confrères monéticiens.","title":"Introduction aux moyens de paiement en Polynésie Française"},{"content":"Ia\u0026rsquo;orana, bonjour !\nCe post marque le début du blog hébergé sur Github.\nVous trouverez ici de temps en temps des articles de développement et des POCs.\nBonne lecture !\n","permalink":"https://huangmanutea.github.io/blog.dev/posts/hello-world/","summary":"Ia\u0026rsquo;orana, bonjour !\nCe post marque le début du blog hébergé sur Github.\nVous trouverez ici de temps en temps des articles de développement et des POCs.\nBonne lecture !","title":"Hello World"}]